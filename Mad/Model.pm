#
# NBGC Project
# 
# Class NBGC::Model - dynamic system model
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# Each instance of this class represents a dynamic system model.  The model
# expresses a system of differential equations by means of a set of variables
# and flows.  An approximate solution to this system of equations can then be
# generated by iteration over a series of time steps.  This is referred to as
# "running" the model, and is controlled by an object of classs NBGC::Simulator.


package Mad::Model;

use strict;
use warnings;
use Carp;
use Exporter qw( import );

%EXPORT_TAGS = ( vartypes => [qw(PLAIN_VAR CONST_VAR POOL_VAR
				 SCALAR_VAR LIST_VAR SET_VAR)],
		 phases => [qw(INIT_PHASE STEP_PHASE TIME_PHASE)]);

our $INPUT_NAME = '<none>';	# Name of the input source being currently read
our $INPUT_LINE = 0;		# Current input line number
our $LOAD_LINE = 0;		# Current input line number when loading
                                # individual statements

use constant {
    PLAIN_VAR => 1,
    CONST_VAR => 2,
    POOL_VAR => 3,
    
    SCALAR_VAR => 1,
    LIST_VAR => 2,
    SET_VAR => 3,
    
    INIT_PHASE => 1,
    STEP_PHASE => 2,
    TIME_PHASE => 3,
};

our @INITIAL_UNITS = ( 'km', 'm', 'cm', 'mm', 'µm', 'nm', 
		       'kg', 'g', 'mg', 'µg', 
		       'yr', 'mo', 'wk', 'day', 'hr', 'min', 
		       's', 'ms', 'µs',
		       'V', 'A', 'W', 'C', 'F', 'H', 'Ω', 'S', 'Wb', 'T',
		       '℃', '℉', 'K',
		       'mol', 
		       'cd', 'lm', 'lx',
		       'Bq', 'Gy', 'Sv', 'kat',
		       'rad', 'sr'
		       'N', 'Pa', 'J');

our @UNIT_ALIASES = ( 'um' => 'µm',
		      'ug' => 'µg',
		      'mcg' => 'µg',
		      'us' => 'us',
		      'year' => 'yr',
		      'mon' => 'mo',
		      'week' => 'wk',
		      'sec' => 's',			# '',
		      'ohm' => 'Ω',
		      'degC' => '℃',
		      'degF' => '℉',
		      );


# Constructor, destructor and related methods
# ===========================================

# new ( )
# 
# Creates a new Model instance.

sub new {

    my $class = shift;
    
    # Create a new object and bless it into the proper class.
    
    my $self = {};
    bless $self, $class;
     
    $self->{symtabs} = { main => {} };
    $self->{current_symtab} = $self->{symtabs}{main};
    $self->{current_prefix} = '';
    
    $self->{units} = $INITIAL_UNITS;
    $self->{symseq} = [];	# List of symbols in the order they were seen
    $self->{initlist} = [];	# List of initialization steps (hashes)
    $self->{flowlist} = [];     # List of flows (hashes)
    $self->{itable} = {};	# Table of initial values and symbol definitions
    $self->{stack} = [];	# Stack for parsing =ifdef and such
    
    return $self;
} 


# DESTROY ()
# 
# Empty destructor method

sub DESTROY {
}


# Methods for dealing with variables
# ----------------------------------

# set_module ( $name )
# 
# Same as the 'module' keyword in Perl.

sub set_module {

    my ($self, $name) = @_;
    
    $self->{symtabs}{$name} = {} unless ref $self->{modules}{$name} eq 'HASH';
    $self->{current_symtab} = $self->{symtabs}{$name};
    $self->{current_prefix} = $name . '::';
}


# declare_var ( $name, $def, $type, $disp, $filename, $line )
# 
# If we have not already seen a variable with this name, add it to the
# model. Otherwise, check to make sure we haven't discovered a conflict such
# as a constant being modified or used as the source or sink of a flow.  The
# parameters 'filename' and 'line' tell us where the variable was defined.

sub declare_var {

    my ($self, $name, $type, $disp, $filename, $line) = @_;
    
    my $sym = $self->{current_symtab}{$name};
    
    # If this is the first time we have encountered this name, add a new entry
    # to the symbol table and return.
    
    unless ( ref $sym eq 'HASH' ) {

	my $prefix = $self->{current_prefix};
	$self->{current_symtab}{$name} = { name => $name,
					   type => $type,
					   disp => $disp,
					   pvar => $prefix . $name;
					   dim => 0,
					   deffn => $filename,
					   defli => $line,
					 };
	
	return 1;
    }
    
    # Otherwise, check to make sure that there is no conflict with the
    # previous use of the variable.
    
    if ( $type > 0 && $sym->{type} > 0 && $type != $sym->{type} ) {
	$self->{parser}->my_error( $sym->{name} . " was already defined as a " .
				   var_type_string($sym->{type}) . " at line " . 
				   $sym->{defli} . " of file " . $sym->{deffn} . "." );
    }
    
    if ( $disp > 0 && $sym->{disp} > 0 && $disp != $sym->{disp} ) {
	$self->{parser}->my_error( $sym->{name} . " was already defined as a " .
				   var_disp_string($sym->{disp}) . " at line " . 
				   $sym->{defli} . " of file " . $sym->{deffn} . "." );
    }
    
    # Since this is supposed to be the actual definition of the variable, and
    # the previous mention was just a use, substitute in the current filename
    # and line number.
    
    $sym->{deffn} = $filename;
    $sym->{defli} = $line;
}

# NEEDED: use of out-of-package variables

sub variable_use {

    my ($self, $name, $set, $phase, $filename, $line) = @_;
    my $sym = $self->{current_symtab}{$name};
    
    # Unless we have already seen this variable, we need to create a record
    # for it.
    
    unless ( ref $sym eq 'HASH' ) {

	my $prefix = $self->{current_prefix};
	$self->{current_symtab}{$name} = { name => $name,
					   pvar => $prefix . $name;
					   deffn => $filename,
					   defli => $line,
					 };
    }
    
    # If this variable has not been set, or is set in a later phase, we need
    # to adjust its attributes:
    
    if ( $sym->{set_phase} == 0 or $phase < $sym->{set_phase} ) {
	
	# if we are currently setting this variable, then note the current
	# phase as the 'set_phase'.  If a value is required in a later phase,
	# we can forget about that since we now know that it will be set sooner.
	
	if ( $set ) {
	    $sym->{set_phase} = $phase;
	    if ( $phase < $sym->{require_phase} ) {
		delete $sym->{require_phase};
	    }
	}
	
	# On the other hand, if we are using the value of this variable, its
	# value is now required to have been set earlier.
	
	else {
	    $self->{require_phase} = $phase;
	}
    }
}

sub parse_init_stmt {

    my ($self, $stmt) = @_;
    my ($const, $name, $expr);
    
    if ( ($const, $name, $expr) = 
	 $stmt =~ / ^ (const\s+)? \$ (\w+) (?: \s* = \s* (.*))/xoi )
    {
	my $sym;
	
	# Check for the 'const' keyword, and register the
	# identifier $name as either a constant or a variable accordingly.
	
	if ( $const ) {
	    $sym = $self->symbol($2, 'const');
	}
	else {
	    $sym = $self->symbol($2);
	}
	
	# If an initialization expression was given, add it to the
	# initialization list for this simulation.
	
	if ( $expr ne '' ) {
	    $self->add_init({sym => $sym, expr => $3});
	}
    }
    
    else
    {
 	croak "Invalid init statement '$stmt' at $INPUT_NAME, line $INPUT_LINE\n";
    }
}


# Parse a "run" statement from the model.  Currently, the only valid run
# statements are flow specifiers.

sub parse_run_stmt {
    
    my ($self, $stmt) = @_;
    
    if ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* : 
		    \s* (\$?-?[\w.]+) \s* \* \s* (\$?-?[\w.]+) $ /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), 
			$self->mult($self->node($3), $self->node($4)));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* : \s* (\$?-?[\w.]+) $ /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), $self->node($3));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* : \s* (.+) /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), $self->expr($3));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* \* \s* (\$?-?[\w.]+) \s* => \s* (\$?\w+) $ /xo )
    { 
	$self->add_flow($self->fs($1), $self->fe($3), 
			$self->mult($self->node($1), $self->node($2)));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* \* \s* (\$?\w+) $ /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), 
			$self->mult($self->node($2), $self->node($3)));
    }
    
    else
    {
	croak "Invalid run statement '$stmt' at $INPUT_NAME, line $INPUT_LINE\n";
    }
}


# Add an initialization record to the model.

sub add_init {
 
    my ($self, $init) = @_;
    
    push @{$self->{initlist}}, $init;
}


# Add a flow start (variable or flow literal) to the model.

sub fs { 
    
    my ($self, $arg) = @_;
    
    if ( $arg =~ /^(?:source|endless|growth)$/i ) {
	return { type => 'flowlit' };
    }
    
    elsif ( $arg =~ /^\$([a-zA-Z_]\w*)$/ ) {
	return $self->symbol($1, 'var');
    }
    
    else {
	croak "Invalid flow start '$arg' at $INPUT_NAME, line $INPUT_LINE";
    }
}


# Add a flow end (variable or flow literal) to the model.

sub fe { 
    
    my ($self, $arg) = @_;
    
    if ( $arg =~ /^(?:sink|endless|decay)$/i ) {
	return { type => 'flowlit' };
    }
    
    elsif ( $arg =~ /^\$([a-zA-Z_]\w*)$/ ) {
	return $self->symbol($1, 'var');
    }
    
    else {
	croak "Invalid flow end '$arg' at $INPUT_NAME, line $INPUT_LINE";
    }
}


# Add a primitive node (variable, constant or literal) to the model.

sub node { 
    
    my ($self, $arg) = @_;
    
    if ( $arg =~ /^\$([a-zA-Z_]\w*)$/ ) {
	return $self->symbol($1);
    }
    
    elsif ( $arg =~ /^\d+$|^\d*\.\d+$|^\d+\.\d*$/ ) {
	return { type => 'literal', value => $1 };
    }
    
    else {
	croak "Can't understand '$arg' at $INPUT_NAME, line $INPUT_LINE";
    }
}


# Add a multiplication node to the model.

sub mult { 
    
    my ($self, @factors) = @_;
    
    return { type => 'prod', child => \@factors };
}


# Add an addition node to the model.

sub sum {

    my ($self, @terms) = @_;
    
    return { type => 'sum', child => \@terms };
}


# Add an arbitrary expression to the model.

sub expr {
    
    my ($self, @terms) = @_;
    
    return { type => 'expr', child => \@terms };
}


# Add a flow record to the model.

sub add_flow {
    
    my ($self, $source, $sink, $rate) = @_;
    
    my $flow = {source => $source, sink => $sink, rate => $rate};
    push @{$self->{flowlist}}, $flow;
}


# Note that the given symbol has been mentioned in the model.  Depending on
# how it is mentioned, it may have type 'const' or 'variable'.  This routine
# will be called more than once for most symbols; it is an error to redefine
# one from 'const' to 'variable' or vice versa.  Returns a reference to the
# symbol record.

sub symbol {

    my ($self, $name, $type) = @_;
    
    # If we have not seen this symbol before, create a new symbol record and
    # add it to the symbol table and sequence list.
    
    unless ( exists $self->{stable}{$name} ) {
	my $sym = $self->{stable}{$name} = NBGC::Symbol->new($name, $type);
        push @{$self->{sseq}}, $sym;
	return $sym;
    }
    
    # Otherwise, check to make sure we are not trying to redefine a constant
    # as a variable or vice versa.
    
    else {
	my $sym = $self->{stable}{$name};
	
	if ( defined($type) && (defined $sym->{type}) && ($type ne $sym->{type}) ) {
	    croak "Invalid redeclaration of $sym->{type} $name to $type \
at $INPUT_NAME, line $INPUT_LINE.\n";
	}
    
	elsif ( defined $type ) {
	    $sym->{type} = $type;
	    $sym->{order} = ( $type eq 'var' ? 1 : 0 );
	}
	
	return $sym;
    }
}


# initial_value ( name, value )
#
# Specifies an initial value for the given identifier (variable or constant),
# overriding any value specified in the model. An undefined value means to
# revert to the value specified in the model. The results of this call are
# persistent across model runs.

sub initial_value {

    my ($self, $name, $value) = @_;
    
    # First look up the identifier, and make sure that it is defined.
    
    my $sym = $self->{stable}{$name};
    
    unless ($sym) {
	carp "Unknown variable '$name'";
    }
    
    # If the value is defined, add it to the initial value table.  Otherwise,
    # remove any definition that may already be there.
    
    if ( defined $value ) {
	$self->{itable}{$name} = $value;
	return 1;
    }
    else {
	delete $self->{itable}{$name} if exists $self->{itable}{$name};
	return 1;
    }
}


package NBGC::Symbol;

# new ( name, type )
# 
# This method creates a new Symbol, with a given name and (optional) type.

sub new {

    my ($class, $name, $type) = @_;
    
    my $self = {};
    bless $self, $class;
    
    $self->{name} = $name;
    $self->{type} = $type;
    $self->{order} = ( defined ($type) && $type eq 'var' ? 1 : 0 );
    
    return $self;
}

# DESTROY ()
# 
# There is no need for anything but an empty destructor method.

sub DESTROY {
}


1;

