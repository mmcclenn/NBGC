#
# NBGC Project
# 
# Class Simulator - dynamic system simulator
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# Each instance of this class represents a dynamic system simulator.  It can
# be loaded with a model, i.e. a set of variables, flows and initial states
# that express a system of differential equations.  An approximate solution to
# this system of equations can then be generated by iteration over a series of
# time steps, using various methods of approximation.  This is referred to as
# "running" the model.
# 
# A model run consists of 5 phases, all of which are optional except the first.
# 
# 1. load	Read in a model and set up the framework necessary to run it
# 2. init	Initialize the model's variables
# 3. spinup	Run the model long enough to establish a steady state, or 
#                 until some specified condition is reached
# 4. run	Run the model for a specified number of time steps, or until a 
#                 specified condition is reached
# 5. output	Display, write or otherwise make available the values of one
#                 or more of the model variables.
# 
# Flags, initial variable values, etc. can be set by the calling package, and
# thus the model can be parametrized.
# 
# 
# Here is an example of usage:
# 
#   $sim = new NBGC::Simulator;
#   
#   $sim->load(file => "model.txt");
#   $sim->initial_value(name => 'somevar', value => 3);
#   
#   $sim->init();
#   $sim->spinup();
#   
#   $sim->record(interval => 1, variables => qw(var1 var2 var3));
#   $sim->run(start => 0, limit => 300);
#   
#   $sim->write_data(file => "output.txt");
#   $sim->plot_var(file => 'var1_plot.png', variable => 'var1');


package NBGC::Simulator;

use strict;
use warnings;
use Carp;
use PDL;

our ($SIM_ID, $INPUT_NAME, $INPUT_LINE, $LOAD_LINE); 

$SIM_ID = 0;			# Gives each Simulator a unique ID number
$INPUT_NAME = '<none>';	        # Name of the input file being currently read
$INPUT_LINE = 0;		# Current input line number
$LOAD_LINE = 0;			# Current input line number when loading
                                # individual statements

# Constructor, destructor and related methods
# ===========================================

# new ( )
# 
# Creates a new Simulator instance.

sub new {

    my $class = shift;
    my $self = {};
    bless $self, $class;
    
    my $id = $NBGC::SIM_ID++;
    $self->{id} = $id;
    $self->{namespace} = "NBGC::Run_$id";
    
    $self->{ctable} = {};    	# Table of constants
    $self->{vtable} = {};	# Table of variables
    $self->{vvector} = [];	# Vector of variables
    $self->{initlist} = [];	# List of initialization statements in Perl
    $self->{load_line} = 0;	# Number of lines loaded as individual statements
    
    return $self;
} 

# DESTROY ()
# 
# Empty destructor method

sub DESTROY {
}


# Methods for phase 1 -- load
# ===========================

# load ( stmt => @stmts )
# load ( file => filename or filehandle )
# 
# Load one or more statements in the Model Definition Language recognized by
# this project.  These are added to any that have already been loaded.  If it
# is desired to reload or redefine the model, clear() must be used.

sub load {
    
    my $self = shift;
    my $selector = shift;
    
    if ( $selector eq 'file' ) {
	local($INPUT_NAME) = shift;
	local($INPUT_LINE) = 0;
	open($infile, $INPUT_NAME) || carp "Could not open file '$INPUT_NAME': $!";
	
	while (<$infile>) {
	    $INPUT_LINE++;
	    &process_line($_);
	}
    }
    
    elsif ( $selector eq 'stmt' ) {
	local($INPUT_NAME) = '<input>';
	local($INPUT_LINE) = $self->{load_line};
	
	foreach (@_) {
	    $INPUT_LINE++;
	    $self->{load_line}++;
	    &process_line($_);
	}
    }
}

# Handle one input line.  Any statement starting with "init" pertains to the
# initialization phase (2), while all other statements pertain to the spinup
# and run phases (3 and 4).

sub process_line {

    my ($line) = @_;
    
    return unless $line =~ /\S/;   # ignore blank lines
    s/^\s*//;			   # take out initial whitespace
    s/\s*$//;			   # take out final whitespace
    
    if ( $line =~ / ^ init \s+ (.*) /xoi )
    {
	&parse_init_stmt($1);
    }
    
    else
    {
	&parse_run_stmt($line);
    }
}


# Parse an "init" statement from the model.  If it specifies a constant,
# register that constant.  If it specifies an initialization expression, put 

sub parse_init_stmt {

    my ($self, $what) = @_;
    my $const;

    if ( $what =~ / ^ (const\s+)? (.*) (?: \s* = \s* (.*))/xoi )
    {
	$self->register_constant($2) if $1 ne '';
	$self->add_init_expr($2, $3) if $3 ne '';
    }
    
    else
    {
 	die "Invalid statement '$what' at $INPUT_FILE, line $INPUT_LINE\n";
    }
}


sub parse_run_stmt {
    
    my ($self, $what) = @_;
    
    given ($what)
    {
	when ( / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* : 
		 \s* \$ (\w+) \s* \* \s* \$ (\w+) $ /xo )
	{
	    $self->add_flow(source => $1, sink => $2, rate1 => $3, rate2 => $4);
	}
	
	when ( / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* : \s* \$ (\w+) $ /xo )
	{
	    $self->add_flow(source => $1, sink => $2, rate1 => $3, rate2 => 1);
	}
	
	when ( / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* : \s* (.+) /xo )
	{
	    $self->add_flow(source => $1, sink => $2, rate_expr => $3);
	}
	
	when ( / ^ \$ (\w+) \s* \* \s* \$ (\w+) \s* -> \s* \$ (\w+) $ /xo )
	{
	    $self->add_flow(source => $1, sink => $3, rate1 => $1, rate2 => $2);
	}
	
	when ( / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* \* \s* \$ (\w+) $ /xo )
	{
	    $self->add_flow(source => $1, sink => $3, rate1 => $3, rate2 => $2);
	}	
	
	default
	{
	    die "Invalid statement '$what' at $INPUT_FILE, line $INPUT_LINE\n";
	}
    }
}


# add_step_stmt : Parse a step statement, and add it to the model.  

sub add_step_stmt {

    my ($self, %args) = @_;
    
    my $source_id = $self->register_variable($args{source});
    my $sink_id = $self->register_variable($args{sink});
    
    if ( defined $args{rate_expr} ) {
	die "Arbtrary rate expressions are not yet supported.\n";
    }
    
    my $const_1 = $self->is_constant($args{rate1});
    my $const_2 = $self->is_constant($args{rate2});
    
    my $rate1_id = $const_1 ? 0 : $self->register_variable($args{rate1});
    my $rate2_id = $const_2 ? 0 : $self->register_variable($args{rate2});
    
}


# register_variable : Given a name, enter it into the model's variable
# table and vector unless it already occurs there.  Return the
# variable's index in the vector.

sub register_variable {

    my ($self, $name) = @_;
}   
    
