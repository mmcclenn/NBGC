#
# NBGC Project
# 
# Class Simulator - dynamic system simulator
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# Each instance of this class represents a dynamic system simulator.  It can
# be loaded with a model, i.e. a set of variables, flows and initial states
# that express a system of differential equations.  An approximate solution to
# this system of equations can then be generated by iteration over a series of
# time steps, using various methods of approximation.  This is referred to as
# "running" the model.
# 
# A model run consists of 5 phases, all of which are optional except the first.
# 
# 1. load	Read in a model and set up the framework necessary to run it
# 2. init	Initialize the model's variables
# 3. spinup	Run the model long enough to establish a steady state, or 
#                 until some specified condition is reached
# 4. run	Run the model for a specified number of time steps, or until a 
#                 specified condition is reached
# 5. output	Display, write or otherwise make available the values of one
#                 or more of the model variables.
# 
# Flags, initial variable values, etc. can be set by the calling package, and
# thus the model can be parametrized.
# 
# 
# Here is an example of usage:
# 
#   $sim = new NBGC::Simulator;
#   
#   $sim->load(file => "model.txt");
#
#   $sim->initial_value(name => 'somevar', value => 3);
#   $sim->init();
#
#   $sim->spinup();
#   
#   $sim->track(interval => 1, variables => qw(var1 var2 var3));
#   $sim->run(start => 0, limit => 300);
#   
#   $sim->write_data(file => "output.txt");
#   $sim->plot_var(file => 'var1_plot.png', variable => 'var1');


package NBGC::Simulator;

use strict;
use warnings;
use Carp;
use PDL;

our ($SIM_ID, $INPUT_NAME, $INPUT_LINE, $LOAD_LINE); 

$SIM_ID = 0;			# Gives each Simulator a unique ID number
$INPUT_NAME = '<none>';	        # Name of the input file being currently read
$INPUT_LINE = 0;		# Current input line number
$LOAD_LINE = 0;			# Current input line number when loading
                                # individual statements

# Constructor, destructor and related methods
# ===========================================

# new ( )
# 
# Creates a new Simulator instance.

sub new {

    my $class = shift;
    my $self = {};
    bless $self, $class;
    
    my $id = $NBGC::SIM_ID++;
    $self->{id} = $id;
    $self->{namespace} = "NBGC::Run_$id";
    
    $self->{vtable} = {};	# Table of variables
    $self->{vvector} = [];	# Vector of variables
    $self->{initlist} = [];	# List of initialization statements in Perl
    $self->{flowlist} = [];     # List of flow statements in Perl
    
    return $self;
} 

# DESTROY ()
# 
# Empty destructor method

sub DESTROY {
}


# Methods for phase 1 -- load
# ===========================

# load ( stmt => @stmts )
# load ( file => filename or filehandle )
# 
# Load one or more statements in the Model Definition Language recognized by
# this project.  These are added to any that have already been loaded.  If it
# is desired to reload or redefine the model, clear() must be used.

sub load {
    
    my $self = shift;
    my $selector = shift;
    
    if ( $selector eq 'file' ) {
	local($INPUT_NAME) = shift;
	local($INPUT_LINE) = 0;
	open($infile, $INPUT_NAME) || croak "Could not open file '$INPUT_NAME': $!";
	
	while (<$infile>) {
	    $INPUT_LINE++;
	    &process_line($_);
	}
    }
    
    elsif ( $selector eq 'stmt' ) {
	local($INPUT_NAME) = '<input>';
	local($INPUT_LINE) = $self->{load_line};
	
	foreach (@_) {
	    $INPUT_LINE++;
	    $self->{load_line}++;
	    &process_line($_);
	}
    }
}

# Handle one input line.  Any statement starting with "init" pertains to the
# initialization phase (2), while all other statements pertain to the spinup
# and run phases (3 and 4).

sub process_line {

    my ($line) = @_;
    
    return unless $line =~ /\S/;   # ignore blank lines
    s/^\s*//;			   # take out initial whitespace
    s/\s*$//;			   # take out final whitespace
    
    if ( $line =~ / ^ init \s+ (.*) /xoi )
    {
	&parse_init_stmt($1);
    }
    
    else
    {
	&parse_run_stmt($line);
    }
}


# Parse an "init" statement from the model.  If it specifies a constant,
# register that constant.  If it specifies an initialization expression, add
# that to the simulation's list of initialization statements.

sub parse_init_stmt {

    my ($self, $stmt) = @_;
    my ($const, $name, $expr);
    
    if ( ($const, $name, $expr) = 
	 $stmt =~ / ^ (const\s+)? (\w+) (?: \s* = \s* (.*))/xoi )
    {
	# Check for the 'const' keyword, and register the
	# identifier $name as either a constant or a variable accordingly.
	
	if ( $const ) {
	    $self->register_variable($2, type => 'const');
	}
	else {
	    $self->register_variable($2);
	}
	
	# If an initialization expression was given, add it to the
	# initialization list for this simulation.
	
	if ( $expr ne '' ) {
	    $self->add_init({var => $2, expr => $3});
	}
    }
    
    else
    {
 	die "Invalid init statement '$stmt' at $INPUT_FILE, line $INPUT_LINE\n";
    }
}


# Parse a "run" statement from the model.  Currently, the only valid run
# statements are flow specifiers.

sub parse_run_stmt {
    
    my ($self, $stmt) = @_;
    
    if ( $stmt =~ / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* : 
		    \s* \$ (\w+) \s* \* \s* \$ (\w+) $ /xo )
    {
	$self->add_flow({source => $1, sink => $2, rate1 => $3, rate2 => $4});
    }
	
    elsif ( $stmt =~ / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* : \s* \$ (\w+) $ /xo )
    {
	$self->add_flow({source => $1, sink => $2, rate1 => $3, rate2 => 1});
    }
    
    elsif ( $stmt =~ / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* : \s* (.+) /xo )
    {
	$self->add_flow({source => $1, sink => $2, rate_expr => $3});
    }
    
    elsif ( $stmt =~ / ^ \$ (\w+) \s* \* \s* \$ (\w+) \s* -> \s* \$ (\w+) $ /xo )
    { 
	$self->add_flow({source => $1, sink => $3, rate1 => $1, rate2 => $2});
    }
    
    elsif ( $stmt =~ / ^ \$ (\w+) \s* -> \s* \$ (\w+) \s* \* \s* \$ (\w+) $ /xo )
    {
	$self->add_flow({source => $1, sink => $2, rate1 => $2, rate2 => $3});
    }
	
    else
    {
	die "Invalid statement '$stmt' at $INPUT_FILE, line $INPUT_LINE\n";
    }
}


# Add an initialization record to the simulation.

sub add_init {

    my ($self, $init) = @_;
    
    push @{self->{initlist}}, $init;
}


# Add a flow record to the simulation.

sub add_flow {
    
    my ($self, $flow) = @_;
    
    # First look at the source; "endless" and "growth" mean a limitless source
    
    if ( $flow->{source} =~ /endless|growth/i ) {
	$flow->{source} = "_";
    }
    else {
	$self->register_variable($flow->{source}, type => 'variable');
    }
    
    # Similarly, "endless" and "decay" mean a limitless sink
    
    if ( $flow->{sink} =~ /endless|decay/i ) {
	$flow->{sink} = "_";
    }
    else {
	$self->register_variable($flow->{sink}, type => 'variable');
    }
    
    # We need to expand the set of supported expressions
    
    if ( defined $flow->{rate_expr} ) {
	die "Arbtrary rate expressions are not yet supported. \
At $INPUT_FILE, line $INPUT_LINE\n";
    }
    
    # Limitless quantities are not valid as rates
    
    if ( $flow->{rate1} =~ /endless|growth|decay/i ) {
	die "Invalid rate coefficient: $flow->{rate1} at $INPUT_FILE, line $INPUT_LINE\n";
    }
    else {
	$self->register_variable($flow->{rate1});
    }
    
    if ( $flow->{rate2} =~ /endless|growth|decay/i ) {
	die "Invalid rate coefficient: $flow->{rate2} at $INPUT_FILE, line $INPUT_LINE\n";
    }
    else {
	$self->register_variable($flow->{rate2});
    }

    # Now that we've validated it, add the flow to the list.
    
    push @{$self->{flowlist}}, $flow;
}


# Note that a variable has been mentioned in the model.  Depending on how it
# is mentioned, it may have type 'const' or 'variable'.  This routine will be
# called more than once for most variables; it is an error to redefine one
# from 'const' to 'variable' or vice versa.

sub register_variable {

    my ($self, $name, undef, $type) = @_;
    
    # First make sure that we actually have a valid identifier
    
    unless ( $name =~ / ^ [a-zA-Z_] \w* $ /xoi ) {
	die "Invalid identifier '$name' at $INPUT_FILE, line $INPUT_LINE\n";
    }
    
    # Then create a new variable record and add it to the variable table.
    
    my $var = ($self->{vtable}{$name}) || 
              ($self->{vtable}{$name} = new NBGC::Variable $name);
    
    # It is not allowed to redefine a variable as a constant or vice
    # versa.  But if the given name was previously used but not
    # given a type, we can assign one now.
    
    if ( defined $type && defined $var->{type} && $var->{type} ne $type ) {
	die "Invalid redeclaration of variable $name to constant \
at $INPUT_FILE, line $INPUT_LINE.\n";
    }
    
    elsif ( defined $type ) {
	$var->{type} = $type;
    }
}
    

# Methods for phase 2 -- init
# ===========================

# initial_value ( name, value )
#
# Specifies an initial value for the given identifier (variable or
# constant).  An undefined value means to use the initial value
# specified in the model.

sub initial_value {

    my ($self, %args) = @_;
    
    # First look up the identifier, and make sure that it is defined.
    
    my $var = $self->{vtable}{$args{name}};
    
    unless ( ref $var eq 'Variable' ) {
	carp "Unknown identifier '$args{name}'";
	return undef;
    }
    
    # Set the value and return true.
    
    $self->{vtable}{initial} = $args{value};
    return 1;
}


# init ( )
# 
# Initialize the model variables prior to a run.  Use the initial
# values specified in the model, unless these were overridden by calls
# to the initial_value() method.  Throw an exception if any of the
# model variables are left without a value.

sub init {



}
