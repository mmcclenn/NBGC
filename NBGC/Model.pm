#
# NBGC Project
# 
# Class NBGC::Model - dynamic system model
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# Each instance of this class represents a dynamic system model.  The model
# expresses a system of differential equations by means of a set of variables
# and flows.  An approximate solution to this system of equations can then be
# generated by iteration over a series of time steps.  This is referred to as
# "running" the model, and is controlled by an object of classs NBGC::Simulator.


package NBGC::Model;

use strict;
use warnings;
use Carp;

our ($INPUT_NAME, $INPUT_LINE, $LOAD_LINE);

$INPUT_NAME = '<none>';	        # Name of the input source being currently read
$INPUT_LINE = 0;		# Current input line number
$LOAD_LINE = 0;			# Current input line number when loading
                                # individual statements


# Constructor, destructor and related methods
# ===========================================

# new ( )
# 
# Creates a new Simulator instance.

sub new {

    my $class = shift;
    
    # Create a new object and bless it into the proper class.
    
    my $self = {};
    bless $self, $class;
     
    $self->{stable} = {};	# Symbol table
    $self->{sseq} = [];		# List of symbols in the order they were seen
    $self->{initlist} = [];	# List of initialization steps (hashes)
    $self->{flowlist} = [];     # List of flows (hashes)
    
    return $self;
} 


# DESTROY ()
# 
# Empty destructor method

sub DESTROY {
}


# Methods for loading the model from source code
# ==============================================

# load ( stmt => @stmts )
# load ( file => filename or filehandle )
# 
# Load one or more statements in the Model Definition Language recognized by
# this project.  These are added to any that have already been loaded.

sub load {
    
    my $self = shift;
    my $selector = shift;
    
    # If we are loading from a file...
    
    if ( $selector eq 'file' ) {
	local($INPUT_NAME) = shift;
	local($INPUT_LINE) = 0;
	open(my $infile, $INPUT_NAME) || croak "Could not open file '$INPUT_NAME': $!";
	
	while (<$infile>) {
	    $INPUT_LINE++;
	    $self->process_line($_);
	}
    }
    
    # If we are loading statements directly...
    
    elsif ( $selector eq 'stmt' ) {
	local($INPUT_NAME) = '<input>';
	local($INPUT_LINE) = $self->{load_line};
	
	foreach (@_) {
	    $INPUT_LINE++;
	    $self->{load_line}++;
	    $self->process_line($_);
	}
    }
    
    return 1;
}

# Handle one input line.  Any statement starting with "init" pertains to the
# initialization phase (2), while all other statements pertain to the spinup
# and run phases (3 and 4).

sub process_line {

    my ($self, $line) = @_;
    
    $line =~ s/#.*//;			# take out comments
    $line =~ s/^\s*//;			# take out initial whitespace
    $line =~ s/\s*$//;			# take out final whitespace
    $line =~ s/;+$//;			# take out final semicolons
    return unless $line =~ /\S/;	# ignore blank lines
    
    if ( $line =~ / ^ init \s+ (.*) /xoi )
    {
	$self->parse_init_stmt($1);
    }
    
    else
    {
	$self->parse_run_stmt($line);
    }
}


# Parse an "init" statement from the model.  If it specifies a constant,
# register that constant.  If it specifies an initialization expression, add
# that to the simulation's list of initialization statements.

sub parse_init_stmt {

    my ($self, $stmt) = @_;
    my ($const, $name, $expr);
    
    if ( ($const, $name, $expr) = 
	 $stmt =~ / ^ (const\s+)? \$ (\w+) (?: \s* = \s* (.*))/xoi )
    {
	my $sym;
	
	# Check for the 'const' keyword, and register the
	# identifier $name as either a constant or a variable accordingly.
	
	if ( $const ) {
	    $sym = $self->symbol($2, 'const');
	}
	else {
	    $sym = $self->symbol($2);
	}
	
	# If an initialization expression was given, add it to the
	# initialization list for this simulation.
	
	if ( $expr ne '' ) {
	    $self->add_init({sym => $sym, expr => $3});
	}
    }
    
    else
    {
 	croak "Invalid init statement '$stmt' at $INPUT_NAME, line $INPUT_LINE\n";
    }
}


# Parse a "run" statement from the model.  Currently, the only valid run
# statements are flow specifiers.

sub parse_run_stmt {
    
    my ($self, $stmt) = @_;
    
    if ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* : 
		    \s* (\$?-?[\w.]+) \s* \* \s* (\$?-?[\w.]+) $ /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), 
			$self->mult($self->node($3), $self->node($4)));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* : \s* (\$?-?[\w.]+) $ /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), $self->node($3));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* : \s* (.+) /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), $self->expr($3));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* \* \s* (\$?-?[\w.]+) \s* => \s* (\$?\w+) $ /xo )
    { 
	$self->add_flow($self->fs($1), $self->fe($3), 
			$self->mult($self->node($1), $self->node($2)));
    }
    
    elsif ( $stmt =~ / ^ (\$?\w+) \s* => \s* (\$?\w+) \s* \* \s* (\$?\w+) $ /xo )
    {
	$self->add_flow($self->fs($1), $self->fe($2), 
			$self->mult($self->node($2), $self->node($3)));
    }
    
    else
    {
	croak "Invalid run statement '$stmt' at $INPUT_NAME, line $INPUT_LINE\n";
    }
}


# Add an initialization record to the model.

sub add_init {
 
    my ($self, $init) = @_;
    
    push @{$self->{initlist}}, $init;
}


# Add a flow start (variable or flow literal) to the model.

sub fs { 
    
    my ($self, $arg) = @_;
    
    if ( $arg =~ /^(?:source|endless|growth)$/i ) {
	return { type => 'flowlit' };
    }
    
    elsif ( $arg =~ /^\$([a-zA-Z_]\w*)$/ ) {
	return $self->symbol($1, 'var');
    }
    
    else {
	croak "Invalid flow start '$arg' at $INPUT_NAME, line $INPUT_LINE";
    }
}


# Add a flow end (variable or flow literal) to the model.

sub fe { 
    
    my ($self, $arg) = @_;
    
    if ( $arg =~ /^(?:sink|endless|decay)$/i ) {
	return { type => 'flowlit' };
    }
    
    elsif ( $arg =~ /^\$([a-zA-Z_]\w*)$/ ) {
	return $self->symbol($1, 'var');
    }
    
    else {
	croak "Invalid flow end '$arg' at $INPUT_NAME, line $INPUT_LINE";
    }
}


# Add a primitive node (variable, constant or literal) to the model.

sub node { 
    
    my ($self, $arg) = @_;
    
    if ( $arg =~ /^\$([a-zA-Z_]\w*)$/ ) {
	return $self->symbol($1);
    }
    
    elsif ( $arg =~ /^\d+$|^\d*\.\d+$|^\d+\.\d*$/ ) {
	return { type => 'literal', value => $1 };
    }
    
    else {
	croak "Can't understand '$arg' at $INPUT_NAME, line $INPUT_LINE";
    }
}


# Add a multiplication node to the model.

sub mult { 
    
    my ($self, @factors) = @_;
    
    return { type => 'prod', child => \@factors };
}


# Add an addition node to the model.

sub sum {

    my ($self, @terms) = @_;
    
    return { type => 'sum', child => \@terms };
}


# Add an arbitrary expression to the model.

sub expr {
    
    my ($self, @terms) = @_;
    
    return { type => 'expr', child => \@terms };
}


# Add a flow record to the model.

sub add_flow {
    
    my ($self, $source, $sink, $rate) = @_;
    
    my $flow = {source => $source, sink => $sink, rate => $rate};
    push @{$self->{flowlist}}, $flow;
}


# Note that the given symbol has been mentioned in the model.  Depending on
# how it is mentioned, it may have type 'const' or 'variable'.  This routine
# will be called more than once for most symbols; it is an error to redefine
# one from 'const' to 'variable' or vice versa.  Returns a reference to the
# symbol record.

sub symbol {

    my ($self, $name, $type) = @_;
    
    # If we have not seen this symbol before, create a new symbol record and
    # add it to the symbol table and sequence list.
    
    unless ( exists $self->{stable}{$name} ) {
	my $sym = $self->{stable}{$name} = NBGC::Symbol->new($name, $type);
        push @{$self->{sseq}}, $sym;
	return $sym;
    }
    
    # Otherwise, check to make sure we are not trying to redefine a constant
    # as a variable or vice versa.
    
    else {
	my $sym = $self->{stable}{$name};
	
	if ( defined($type) && (defined $sym->{type}) && ($type ne $sym->{type}) ) {
	    croak "Invalid redeclaration of $sym->{type} $name to $type \
at $INPUT_NAME, line $INPUT_LINE.\n";
	}
    
	elsif ( defined $type ) {
	    $sym->{type} = $type;
	    $sym->{order} = ( $type eq 'var' ? 1 : 0 );
	}
	
	return $sym;
    }
}


package NBGC::Symbol;

# new ( name, type )
# 
# This method creates a new Symbol, with a given name and (optional) type.

sub new {

    my ($class, $name, $type) = @_;
    
    my $self = {};
    bless $self, $class;
    
    $self->{name} = $name;
    $self->{type} = $type;
    $self->{order} = ( defined ($type) && $type eq 'var' ? 1 : 0 );
    
    return $self;
}

# DESTROY ()
# 
# There is no need for anything but an empty destructor method.

sub DESTROY {
}


1;

