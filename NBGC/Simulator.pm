#
# NBGC Project
# 
# Class Simulator - dynamic system simulator
# 
# Author: Michael McClennen
# Copyright (c) 2010 University of Wisconsin-Madison
# 
# Each instance of this class represents a dynamic system simulator.  It can
# be loaded with a model, i.e. a set of variables, flows and initial states
# that express a system of differential equations.  An approximate solution to
# this system of equations can then be generated by iteration over a series of
# time steps, using various methods of approximation.  This is referred to as
# "running" the model.
# 
# A model run consists of 4 phases:
# 
# 1. init	Initialize the model's variables
# 2. spinup	Run the model long enough to establish a steady state, or 
#                 until some specified condition is reached (optional)
# 3. run	Run the model for a specified number of time steps, or until a 
#                 specified condition is reached
# 4. output	Display, write or otherwise make available the values of one
#                 or more of the model variables.
# 
# Flags, initial variable values, etc. can be set at any time, in order to
# parametrize the model.
# 
# 
# Here is an example of usage:
# 
#   $model = new NBGC::Model;
#   $model->load(file => "model.txt");
#   
#   $sim = new NBGC::Simulator;
#   
#   $sim->load($model);
#   $sim->initial_value('some_constant', 3);
#   $sim->init();
#   
#   $sim->spinup();
#   $sim->set_value('other_constant', 5.012);
#   
#   $sim->trace('all');
#   $sim->run(start => 0, limit => 300);
#   
#   $sim->write_data(file => "output.txt");
#   $sim->plot_var(file => 'var1_plot.png', variable => 'var1');


package NBGC::Simulator;

use strict;
use warnings;
use Carp;

our ($SIM_ID, $INTEGRATION_METHOD); 

$SIM_ID = 0;			# Gives each Simulator a unique ID number
$INTEGRATION_METHOD = 'SIMPLE';	# Which method of numerical
                                # Integration to use.

# Constructor, destructor and related methods
# ===========================================

# new ( )
# 
# Creates a new Simulator instance.

sub new {

    my $class = shift;

    # Create a new instance and bless into the proper class.
    
    my $self = {};    
    bless $self, $class;
    
    my $id = $NBGC::SIM_ID++;
    $self->{id} = $id;
    $self->{runspace} = "NBGC::Run_$id";
    $self->{state} = 'CLEAR';	# States are:
    				#   CLEAR - empty, waiting for a model
				#   READY - the model is ready to run
				#   INIT - the vars are being initialized
				#   SPINUP - running in spinup mode
    				#   RUN - running in regular mode
    
    $self->{model} = undef;     # The model.  Next few are model components
    $self->{stable} = undef;	#   symbol table
    $self->{sseq} = undef;	#   symbol sequence list
    $self->{initlist} = undef;	#   list of symbol initializations
    $self->{flowlist} = undef;  #   list of flows
    $self->{itable} = {};	# table of initial symbol value overrides
    $self->{initprog} = undef;	# code ref for initialization
    $self->{runprog} = undef;	# code ref for one run step
    $self->{traceprog} = undef;	# code ref for one data trace step
    $self->{run_start} = undef; # at what value of t did the last run start?
    $self->{run_end} = undef;	# at what value of t did the last run end?
    
    return $self;
}

# DESTROY ()
# 
# Empty destructor method

sub DESTROY {
}


# Methods for loading a model
# ===========================

# load ( model ) - load in a model

sub load {    

    my ($self, $model, $time_unit) = @_;
    
    croak "Valid model required" unless ref $model eq 'NBGC::Model';
    croak "Interval must be >= 1" if defined $interval and !($interval > 1);
    
    $self->{model} = $model;
    $self->{t_unit} = $time_unit || 1;
    $self->{stable} = $model->{stable};
    $self->{sseq} = $model->{sseq};
    $self->{initlist} = $model->{initlist};
    $self->{flowlist} = $model->{flowlist};
    
    $self->compile_runprog();
    $self->compile_traceprog();
    $self->init_runspace();
    $self->{state} = 'READY';
}


# Compile the model that is currently loaded into the given Simulator object
# using the PERL method -- the initialization and each step of the model
# become pure Perl functions.  Variable values are all kept in the package
# NBGC_Run_$id where $id is a unique identifier assigned to this Simulator object.

sub compile_runprog {

    my $self = shift;
    
    # First, compile the initialization step.
    
    my $CODE = "package $self->{runspace};\nno strict 'vars';\n\n";
    
    foreach my $init (@{$self->{initlist}}) {
	my ($sym, $expr) = ($init->{sym}, $init->{expr});
	my $name = $sym->{name};
	
	$CODE .= "\$$name = (defined \$self->{itable}{'$name'} ? \$self->{itable}{'$name'} : $expr);\n";
    }
    
    eval("\$self->{initprog} = sub {\n$CODE\n}");
    
    if ( $@ ) {
	croak "Error in initialization program: $@";
    }
    
    # Next, compile the run step.
    
    $CODE = "package $self->{runspace};\nno strict 'vars';\n\n";
    
    foreach my $flow (@{$self->{flowlist}}) {
	my $source = $flow->{source};
	my $sink = $flow->{sink};
	if ( defined $flow->{rate_expr} ) {
	    if ( !defined($source) ) {
		$CODE .= "\$$sink->{name} += $flow->{rate_expr};\n";
	    }
	    elsif ( !defined($sink) ) {
		$CODE .= "\$$source->{name} -= $flow->{rate_expr};\n";
	    }
	    else {
		$CODE .= "{\nmy \$val = $flow->{rate_expr};\n";
		$CODE .= "\$$source->{name} -= \$val; \$$sink->{name} += \$val;\n}\n";
	    }
	}
	
	elsif ( $flow->{rate2} eq '1' ) {
	    $CODE .= "\$$source -= \$$flow->{rate1};\n" if $source ne '_';
	    $CODE .= "\$$sink += \$$flow->{rate1};\n" if $sink ne '_';
	}
	
	else {
	    $CODE .= "\$$source->{name} -= \$$flow->{rate1}{name} * \$$flow->{rate2}{name}; " if defined($source);
	    $CODE .= "\$$sink->{name} += \$$flow->{rate1}{name} * \$$flow->{rate2}{name}; " if defined($sink);
	    $CODE .= "\n";
	}
    }
    
    eval("\$self->{runprog} = sub {\n$CODE\n}");
    
    if ( $@ ) {
	croak "Error in run program: $@";
    }
    
    return 1;
}


# List all of the model's variables

sub variables {

    my $self = shift;

    my @vars = map { $_->{name} } grep { $_->{type} eq 'var' } @{$self->{sseq}};
    return @vars;
}


# Create a trace function for the current model.

sub compile_traceprog {

    my $self = shift;
    
    # First get a list of all of the variables
    
    my @vars = $self->variables();
    
    # Then generate code to trace them
    
    my $CODE = "package $self->{runspace};\nno strict 'vars';\n\n";
    $CODE .= "push \@{\$_TRACE{'T'}}, \$T;\n";
    
    foreach my $var (@vars) {
	$CODE .= "push \@{\$_TRACE{'$var'}}, \$$var;\n";
    }
    
    eval("\$self->{traceprog} = sub {\n$CODE\n}");
    
    if ( $@ ) {
	croak "Error in trace program: $@";
    }
    
    return 1;
}


# init_runspace ( ) - Make sure that the package used as the namespace for
# running the model is clear of everything except the necessary variables.
# This should be called once before every run, so that each run is done de novo.

sub init_runspace {

    my $self = shift;
    my $pkgname = $self->{runspace} . '::';
    
    no strict 'refs';
    my @vars = keys %$pkgname;
    
    foreach my $var (@vars) {
	undef $$pkgname{$var};
    }
    
    my $CODE << ENDCODE;
package $pkgname;
no strict 'vars';
our (\$T, \$t);

\$T = 0;
*t = \\\$T;
ENDCODE
    
    eval $CODE;
    
    if ( $@ ) {
	croak "Error in runspace init: $@";
    }
    
    return 1;
}


# reset ( ) - reset the simulator for another model run

sub reset {
    
    my $self = shift;
    
    $self->init_runspace();
    $self->{state} = 'READY';
}


# Methods for phase 1 -- init
# ===========================

# initial_value ( name, value )
#
# Specifies an initial value for the given identifier (variable or constant),
# overriding any value specified in the model. This routine is only
# immediately effective if called before init(), or just after a reset(). An
# undefined value means to revert to the value specified in the model. The
# results of this call are persistent across model runs.

sub initial_value {

    my ($self, $name, $value) = @_;
    
    # First look up the identifier, and make sure that it is defined.
    
    my $sym = $self->{stable}{$name};
    
    unless ($sym) {
	carp "Unknown variable '$name'";
	return undef;
    }
    
    # Set the value and return true.
    
    $self->{itable}{$name} = $value;
    return 1;
}


# set_value ( name, value )
# 
# Specifies a new value for the given identifier (variable or constant),
# overriding any value specified in the model.  This routine can be called at
# any point in the simulation, but its effects only last until the variable is
# changed by the model code or until the next reset() upon which time the
# variable or constant is reset to its initial value as specified in the model
# or overridden by set_init_value().

sub set_value {

    my ($self, $name, $value) = @_;
    
    # First look up the identifier, and make sure that it is defined.
    
    my $sym = $self->{stable}{$name};
    
    unless ($sym) {
	carp "Unknown variable '$name'";
	return undef;
    }
    
    # Set the value.
    
    eval "package $self->{runspace}; no strict 'vars'; \$$name = $value;";
    
    return 1;
}


# init ( )
# 
# Reset the simulator (if necessary) and then initialize the model variables
# for a new run. Use the initial values specified in the model, unless these
# were overridden by calls to the initial_value() method.

sub init {

    my ($self) = @_;
    
    # First check if we have a model loaded yet.
    
    if ( $self->{state} eq 'CLEAR' ) {
	croak "No model loaded.";
	return undef;
    }
    
    # If the state is anything but READY, reset the simulator
    # first.
    
    elsif ( $self->{state} ne 'READY' ) {
	$self->reset();
    }
    
    # Now, we are ready to initialize the variables.
    
    $self->{state} = 'INIT';
    &{$self->{initprog}};
    
    return 1;
}


# trace ( interval, exprlist )
# 
# Add the given expressions to the trace list.

sub trace {
    
    my ($self, %args) = @_;
    
    my $interval = $args{interval} || 1;
    my $varcount = 0;
    
    my (@vars) = split /\s*,\s*/, $args{vars};
    if ( uc $vars[0] eq 'ALL' ) {
	@vars = grep { $self->{vtable}{$_}{type} eq 'variable' } keys %{$self->{vtable}};
    }
    
    foreach my $expr (@vars) {
	$varcount++;
	my $var = $self->{vtable}{$expr} or
	    carp "Warning: '$expr' is not a known variable";
	push @{$self->{tracelist}}, $expr;
    }
    
    $self->{trace_compiled} = undef;
}


# clear_trace ( )
# 
# Clear the trace list

sub clear_trace {
    
    my $self = shift;
    
    $self->{tracelist} = [];
    $self->{traceprog} = undef;
    $self->{trace_compiled} = 1;
}


# Methods for phase 3 -- spinup
# ============================

# Methods for phase 4 -- run
# ==========================

# run ( start, limit, increment, continue )
# 
# Run the model.  The start parameter, if given, specifies the initial time.
# It defaults to 0, unless we are continuing a previous run in which case it
# defaults to the time at the end of the previous run. The limit, if given,
# specifies the ending time.  The increment, if given, specifies the time
# increment and defaults to 1.  If continue is given a true value, we will
# continue the run from where we previously left off.

sub run {

    my ($self, %args) = @_;
    
    my $start = ($args{start} && $args{start} > 0) ? $args{start} : 0;
    
    if ( $args{continue} ) {
	if ( defined $self->{run_end} ) {
	    $start = $self->{run_end};
	}
	
	else {
	    croak "No run to continue from.";
	}
    }
    
    my $limit = $args{limit};
    
    $self->{state} = 'RUN';
    
    # Make sure the trace program is compiled.
    
    $self->compile_traceprog() unless $self->{trace_compiled};
    
    # Find the time variable, and initialize it.
    
    my $t_ref = $self->init_run_time($start);
    
    # If we are just starting up, set up the trace do an initial trace.
    
    unless ( defined $self->{run_end} && $self->{run_end} == $start ) {
	$self->init_trace(($limit - $start + 1) * $self->{t_unit});
	&{$self->{traceprog}};
    }
    
    # Now, loop through run steps
    
    until ( $$t_ref >= $limit ) {
	
	&{$self->{runprog}} if defined $self->{runprog};
	$self->increment_run_time($t_ref);
	&{$self->{traceprog}} if defined $self->{traceprog};
    }
    
    # Finish up
    
    $self->{run_end} = $$t_ref;
    return 1;
}


# Set the initial time, and return a reference to the time variable.

sub init_run_time {
    
    my ($self, $start_time) = @_;
    
    my $t_ref;
    eval("\$t_ref = \\\$$self->{runspace}::T");
    $$t_ref = $self->{run_start} = $start_time;
    
    return $t_ref;
}


sub increment_run_time {
    
    my ($self, $t_ref) = @_;
    
    $$t_ref += $self->{t_unit};
}


# set up for the trace program

sub init_trace {
    
    my ($self, $tracesize) = @_;
    my $traceref;
    
    eval("package $self->{runspace}; \%_TRACE = (); \$traceref = \\\%_TRACE;");
    
    $traceref->{'T'} = [];
    
    foreach my $expr (@{$self->{tracelist}}) {
	if ( $expr =~ /^\w/ ) { $expr = '$' . $expr; }
	$traceref->{'$expr'} = [];
    }
    
    return 1;
}

# Methods for phase 5 -- output
# =============================

# trace_vars ( ) - return a list of variables being traced

sub trace_vars { 

    my $self = shift;
    
    return @{$self->{tracelist}};
}

# dump_trace ( ) - dump the trace data to the given file handle

sub dump_trace {

    my ($self, %args) = @_;
    
    my $fh = $args{file};
    my @vars = $self->variables();
    
    my $dataref;
    eval "\$dataref = \\\%$self->{runspace}::_TRACE";
    my $datacount = scalar @{$dataref->{T}};
    
    foreach my $i (0..$datacount-1) {
	print $fh $dataref->{T}[$i], "\t";
	foreach my $var (@vars) {
	    print $fh $dataref->{$var}[$i], "\t";
	}
	print $fh "\n";
    }
}


# get_values ( variable ) - returns a list of the trace values of the
# given variable.  T returns time.

sub get_values {
    
    my ($self, $expr) = @_;
    
    my $dataref;
    eval "\$dataref = \\\%$self->{runspace}::_TRACE";
    my $datacount = scalar @{$dataref->{T}};
    
    if ( $expr eq 'T' ) {
	return @{$dataref->{$expr}};
    }
    
    else {
	my @vals;
	foreach my $i (0..$datacount-1) {
	    push @vals, $dataref->{$expr}[$i];
	}
	return @vals;
   }
}


# minmax_values ( @values ) - return the minimum and maximum of the list of values.

sub minmax_values {

    my $self = shift;
    my $min = shift;
    my $max = shift;
    
    foreach (@_) {
	$min = $_ if $_ < $min;
	$max = $_ if $_ > $max;
    }
    
    return ($min, $max);
}

# We have to end the module with a true value.

1;
